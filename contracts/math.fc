{-
    math.fc

    This library provide functions for math. 
-}


;; internal constants

const int __math::ONE_18 = 1000000000000000000; ;; 1e18
const int __math::ONE_20 = 100000000000000000000; ;; 1e20
const int __math::ONE_36 = 1000000000000000000000000000000000000; ;; 1e36
const int __math::MAX_NATURAL_EXPONENT = 130000000000000000000; ;; 130e18
const int __math::MIN_NATURAL_EXPONENT = -41000000000000000000;   ;; -41e18
const int __math::LN_36_LOWER_BOUND = __math::ONE_18 - 100000000000000000; ;; ONE_18 - 1e17
const int __math::LN_36_UPPER_BOUND = __math::ONE_18 + 100000000000000000; ;; ONE_18 + 1e17
const int __math::MILD_EXPONENT_BOUND = 28948022309329048855892746252171976963317496166410141009864396001978282409984 / __math::ONE_20; ;; 2**254 / ONE_20
const int __math::e   = 2718281828459045235;      ;; e
const int __math::x0  = 128000000000000000000;    ;; 2ˆ7
const int __math::a0  = 38877084059945950922200000000000000000000000000000000000; ;; eˆ(x0) (no decimals)
const int __math::x1  = 64000000000000000000;     ;; 2ˆ6
const int __math::a1  = 6235149080811616882910000000; ;; eˆ(x1) (no decimals)
const int __math::x2  = 3200000000000000000000;   ;; 2ˆ5
const int __math::a2  = 7896296018268069516100000000000000; ;; eˆ(x2)
const int __math::x3  = 1600000000000000000000;   ;; 2ˆ4
const int __math::a3  = 888611052050787263676000000; ;; eˆ(x3)
const int __math::x4  = 800000000000000000000;    ;; 2ˆ3
const int __math::a4  = 298095798704172827474000; ;; eˆ(x4)
const int __math::x5  = 400000000000000000000;    ;; 2ˆ2
const int __math::a5  = 5459815003314423907810;   ;; eˆ(x5)
const int __math::x6  = 200000000000000000000;    ;; 2ˆ1
const int __math::a6  = 738905609893065022723;    ;; eˆ(x6)
const int __math::x7  = 100000000000000000000;    ;; 2ˆ0
const int __math::a7  = 271828182845904523536;    ;; eˆ(x7)
const int __math::x8  = 50000000000000000000;     ;; 2ˆ-1
const int __math::a8  = 164872127070012814685;    ;; eˆ(x8)
const int __math::x9  = 25000000000000000000;     ;; 2ˆ-2
const int __math::a9  = 128402541668774148407;    ;; eˆ(x9)
const int __math::x10 = 12500000000000000000;     ;; 2ˆ-3
const int __math::a10 = 113314845306682631683;    ;; eˆ(x10)
const int __math::x11 = 6250000000000000000;      ;; 2ˆ-4
const int __math::a11 = 106449445891785942956;    ;; eˆ(x11)

;; public constants

const int math::MAX_UINT8   = 0xFF; 
const int math::MAX_UINT16  = 0xFFFF; 
const int math::MAX_UINT32  = 0xFFFFFFFF; 
const int math::MAX_UINT64  = 0xFFFFFFFFFFFFFFFF; 
const int math::MAX_UINT128 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; 
const int math::MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; 
const int math::one_dec     = __math::ONE_18;         ;; 1      with 18 decimals
const int math::e           = __math::e;              ;; e      with 18 decimals
const int math::pi          = 3141592653589793238;  ;; pi     with 18 decimals
const int math::pi_sq       = 9869604401089358618;  ;; pi^2   with 18 decimals
const int math::1_div_e     = 0367879441171442321;  ;; 1/e    with 18 decimals
const int math::1_div_pi    = 0318309886183790671;  ;; 1/pi   with 18 decimals
const int math::1_div_pi_sq = 0101321183642337771;  ;; 1/pi^2 with 18 decimals


;; errors

const math::error::x_out_of_bounds       = 50001;
const math::error::y_out_of_bounds       = 50002;
const math::error::product_out_of_bounds = 50003;
const math::error::invalid_exponent      = 50004;
const math::error::out_of_bounds         = 50005;
const math::error::0_base                = 50006;
const math::error::negative_power        = 50007;


;; internal functions

int __math::ln_36(int _x) impure inline_ref {
    _x *= __math::ONE_18;
    int z = muldiv((_x - __math::ONE_36), __math::ONE_36, (_x + __math::ONE_36));
    int z_squared = muldiv(z, z, __math::ONE_36);

    int num = z;
    int series_sum = num;

    num = muldiv(num, z_squared, __math::ONE_36);
    series_sum += num / 3;

    num = muldiv(num, z_squared, __math::ONE_36);
    series_sum += num / 5;

    num = muldiv(num, z_squared, __math::ONE_36);
    series_sum += num / 7;

    num = muldiv(num, z_squared, __math::ONE_36);
    series_sum += num / 9;

    num = muldiv(num, z_squared, __math::ONE_36);
    series_sum += num / 11;

    num = muldiv(num, z_squared, __math::ONE_36);
    series_sum += num / 13;

    num = muldiv(num, z_squared, __math::ONE_36);
    series_sum += num / 15;

    return series_sum * 2;
}


int __math::ln(int _a) impure inline_ref {
    if _a < __math::ONE_18 { return negate(__math::ln((__math::ONE_18 * __math::ONE_18) / _a)); }

    int sum = 0;
    if _a >= __math::a0 * __math::ONE_18 {
        _a /= __math::a0; 
        sum += __math::x0;
    }

    if _a >= __math::a1 * __math::ONE_18 {
        _a /= __math::a1; 
        sum += __math::x1;
    }

    sum *= 100;
    _a *= 100;

    if _a >= __math::a2 {
        _a = muldiv(_a, __math::ONE_20, __math::a2);
        sum += __math::x2;
    }

    if _a >= __math::a3 {
        _a = muldiv(_a, __math::ONE_20, __math::a3);
        sum += __math::x3;
    }

    if _a >= __math::a4 {
        _a = muldiv(_a, __math::ONE_20, __math::a4);
        sum += __math::x4;
    }

    if _a >= __math::a5 {
        _a = muldiv(_a, __math::ONE_20, __math::a5);
        sum += __math::x5;
    }

    if _a >= __math::a6 {
        _a = muldiv(_a, __math::ONE_20, __math::a6);
        sum += __math::x6;
    }

    if _a >= __math::a7 {
        _a = muldiv(_a, __math::ONE_20, __math::a7);
        sum += __math::x7;
    }

    if _a >= __math::a8 {
        _a = muldiv(_a, __math::ONE_20, __math::a8);
        sum += __math::x8;
    }

    if _a >= __math::a9 {
        _a = muldiv(_a, __math::ONE_20, __math::a9);
        sum += __math::x9;
    }

    if _a >= __math::a10 {
        _a = muldiv(_a, __math::ONE_20, __math::a10);
        sum += __math::x10;
    }

    if _a >= __math::a11 {
        _a = muldiv(_a, __math::ONE_20, __math::a11);
        sum += __math::x11;
    }

    int z = muldiv((_a - __math::ONE_20),  __math::ONE_20, (_a + __math::ONE_20));
    int z_squared = muldiv(z, z, __math::ONE_20);

    int num = z;
    int series_sum = num;

    num = muldiv(num, z_squared, __math::ONE_20);
    series_sum += num / 3;

    num = muldiv(num, z_squared, __math::ONE_20);
    series_sum += num / 5;

    num = muldiv(num, z_squared, __math::ONE_20);
    series_sum += num / 7;

    num = muldiv(num, z_squared, __math::ONE_20);
    series_sum += num / 9;

    num = muldiv(num, z_squared, __math::ONE_20);
    series_sum += num / 11;

    series_sum *= 2;

    int result = (sum + series_sum) / 100;
    return result;
}


;; public functions

int math::sqrt(int x) inline {
    if (x == 0) { return x; }

    int r = 181;
    int xx = x;
    if (xx >= 0x100000000000000000000000000000000) {
        xx >>= 128;
        r <<= 64;
    }
    if (xx >= 0x10000000000000000) {
        xx >>= 64;
        r <<= 32;
    }
    if (xx >= 0x100000000) {
        xx >>= 32;
        r <<= 16;
    }
    if (xx >= 0x10000) {
        xx >>= 16;
        r <<= 8;
    }

    r = (r * (xx + 65536)) >> 18;

    repeat(7) {
        r = (r + x / r) >> 1;
    }

    int r1 = x / r;

    return (r < r1 ? r : r1);
}


;; _a should have 18 decimals -> returns with 18 decimals
int math::ln(int _a) impure inline_ref {
    if _a == __math::e { return __math::ONE_18; }
    if _a == __math::ONE_18 { return 0; }

    throw_unless(math::error::out_of_bounds, _a > 0);

    if (__math::LN_36_LOWER_BOUND < _a) & (_a < __math::LN_36_UPPER_BOUND) {
        return __math::ln_36(_a) / __math::ONE_18;
    } else {
        return __math::ln(_a);
    }
}


;; _arg and _base should have 18 decimals -> returns with 18 decimals
int math::log(int _arg, int _base) impure inline_ref {
    throw_if(math::error::0_base, _base == 0);
    if _arg == __math::ONE_18 { return 0; }

    int log_base = 0;
    if (__math::LN_36_LOWER_BOUND < _base) & (_base < __math::LN_36_UPPER_BOUND) {
        log_base = __math::ln_36(_base);
    } else {
        log_base = __math::ln(_base) * __math::ONE_18;
    }

    int log_arg = 0;
    if (__math::LN_36_LOWER_BOUND < _arg) & (_arg < __math::LN_36_UPPER_BOUND) {
        log_arg = __math::ln_36(_arg);
    } else {
        log_arg = __math::ln(_arg) * __math::ONE_18;
    }

    return (log_arg * __math::ONE_18) / log_base;
}


;; _x should have 18 decimals -> returns with 18 decimals
int math::exp(int _x) impure inline_ref {
    if _x == __math::ONE_18 { return __math::e; }
    throw_unless(math::error::invalid_exponent, 
        (_x >= __math::MIN_NATURAL_EXPONENT) & (_x <= __math::MAX_NATURAL_EXPONENT));

    if _x < 0 { return (__math::ONE_18 * __math::ONE_18) / math::exp(_x.negate()); }

    int first_AN = 0;
    if _x >= __math::x0 {
        _x -= __math::x0;
        first_AN = __math::a0;
    } elseif _x >= __math::x1 {
        _x -= __math::x1;
        first_AN = __math::a1;
    } else {
        first_AN = 1; 
    }

    _x *= 100;

    int product = __math::ONE_20;
    if _x >= __math::x2 {
        _x -= __math::x2;
        product = muldiv(product, __math::a2, __math::ONE_20);
    }
    if _x >= __math::x3 {
        _x -= __math::x3;
        product = muldiv(product, __math::a3, __math::ONE_20);
    }
    if _x >= __math::x4 {
        _x -= __math::x4;
        product = muldiv(product, __math::a4, __math::ONE_20);
    }
    if _x >= __math::x5 {
        _x -= __math::x5;
        product = muldiv(product, __math::a5, __math::ONE_20);
    }
    if _x >= __math::x6 {
        _x -= __math::x6;
        product = muldiv(product, __math::a6, __math::ONE_20);
    }
    if _x >= __math::x7 {
        _x -= __math::x7;
        product = muldiv(product, __math::a7, __math::ONE_20);
    }
    if _x >= __math::x8 {
        _x -= __math::x8;
        product = muldiv(product, __math::a8, __math::ONE_20);
    }
    if _x >= __math::x9 {
        _x -= __math::x9;
        product = muldiv(product, __math::a9, __math::ONE_20);
    }

    int series_sum = __math::ONE_20; 
    int term = _x; 
    series_sum += term;

    term = muldiv(term, _x, __math::ONE_20 * 2);
    series_sum += term;

    term = muldiv(term, _x, __math::ONE_20 * 3);
    series_sum += term;

    term = muldiv(term, _x, __math::ONE_20 * 4);
    series_sum += term;

    term = muldiv(term, _x, __math::ONE_20 * 5);
    series_sum += term;

    term = muldiv(term, _x, __math::ONE_20 * 6);
    series_sum += term;

    term = muldiv(term, _x, __math::ONE_20 * 7);
    series_sum += term;

    term = muldiv(term, _x, __math::ONE_20 * 8);
    series_sum += term;

    term = muldiv(term, _x, __math::ONE_20 * 9);
    series_sum += term;

    term = muldiv(term, _x, __math::ONE_20 * 10);
    series_sum += term;

    term = muldiv(term, _x, __math::ONE_20 * 11);
    series_sum += term;

    term = muldiv(term, _x, __math::ONE_20 * 12);
    series_sum += term;
    
    return muldiv(muldiv(product, series_sum, __math::ONE_20), first_AN, 100);
}

;; _x and _y should have 18 decimals -> returns with 18 decimals
int math::pow(int _x, int _y) impure inline_ref {
    if _y == 0 { return __math::ONE_18; }
    if _x == 0 { return 0; }
    if _x == __math::ONE_18 { return __math::ONE_18; }

    throw_unless(math::error::x_out_of_bounds, _x >> 256 == 0);
    throw_unless(math::error::y_out_of_bounds, _y < __math::MILD_EXPONENT_BOUND);

    int logx_times_y = 0;
    if (__math::LN_36_LOWER_BOUND < _x) & (_x < __math::LN_36_UPPER_BOUND) {
        int ln_36_x = __math::ln_36(_x);
        logx_times_y = (ln_36_x / __math::ONE_18) * _y + ((ln_36_x % __math::ONE_18) * _y) / __math::ONE_18;
    } else {
        logx_times_y = __math::ln(_x) * _y;
    }
    logx_times_y /= __math::ONE_18;
    throw_unless(math::error::product_out_of_bounds, 
        (__math::MIN_NATURAL_EXPONENT <= logx_times_y) & (logx_times_y <= __math::MAX_NATURAL_EXPONENT));

    return math::exp(logx_times_y);
}

;; _x and _y with no decimals -> returns with 18 decimals
int math::pow_nodec(int _x, int _y) impure inline { 
    return math::pow(_x * __math::ONE_18, _y * __math::ONE_18);
}

;; _x with no decimals -> returns with 18 decimals
int math::exp_nodec(int _x) impure inline { 
    return math::exp(_x * __math::ONE_18);
}

;; _arg and _base with no decimals -> returns with 18 decimals
int math::log_nodec(int _arg, int _base) impure inline { 
    return math::log(_arg * __math::ONE_18, _base * __math::ONE_18);
}

;; _a with no decimals -> returns with 18 decimals
int math::ln_nodec(int _a) impure inline { 
    return math::ln(_a * __math::ONE_18);
}

;; _x and _y without decimals -> returns with no decimals
int math::int_pow(int _x, int _y) impure inline_ref {
    if _y == 0 { return 1; }
    if _x == 0 { return 0; }
    if _x == 1 { return 1; }
    throw_unless(math::error::negative_power, _y > 0);

    int res = 1;
    while _y > 0 {
        if _y & 1 {
            res = res * _x;
        }
        _y = _y >> 1; 
        _x = _x * _x; 
    }

    return res;
}

;; _x has 18 decimals -> returns with 18 decimals
int math::int_pow_dec(int _x, int _y) impure inline_ref {
    if _y == 0 { return __math::ONE_18; }
    if _x == 0 { return 0; }
    if _x == __math::ONE_18 { return __math::ONE_18; }
    throw_unless(math::error::negative_power, _y > 0);

    int res = __math::ONE_18;
    while _y > 0 {
        if _y & 1 {
            res = muldiv(res, _x, __math::ONE_18);
        }
        _y = _y >> 1; 
        _x = muldiv(_x, _x, __math::ONE_18); 
    }

    return res;
}

;; add 18 decimals
int math::to_dec(int _x) inline {
    return _x * __math::ONE_18;
}

;; remove 18 decimals (floor)
int math::rm_dec(int _x) inline {
    return _x / __math::ONE_18;
}

;; remove 18 decimals (ceil)
int math::rm_dec_ceil(int _x) inline {
    return _x ^/ __math::ONE_18;
}

;; remove 18 decimals (round)
int math::rm_dec_round(int _x) inline {
    return _x ~/ __math::ONE_18;
}

;; div 2 ints with decimals -> returns with decimals
int math::div_dec(int _x, int _y) inline {
    return muldiv(__math::ONE_18, _x, _y);
}

;; mul 2 ints with decimals -> returns with decimals
int math::mul_dec(int _x, int _y) inline {
    return muldiv(_x, _y, __math::ONE_18);
}

;; same as regular muldiv because extra __math::ONE_18 cancel each other out in div and mul
int math::muldiv_dec(int _x, int _y, int _z) inline {
    ;; ((x * y / __math::ONE_18) * __math::ONE_18 / z) = x * y / z
    return muldiv(_x, _y, _z);
}


