{-
    address.fc

    This library provide an abstraction layer over an MsgAddressInt type. 
-}

([int, int, slice]) address::empty() inline {
    return [null(), null(), addr_none()];
}

([int, int, slice]) address::from_std(int wc, int hp) inline {
    return [wc, hp, null()];
}

([int, int, slice]) address::from_serialized_std(slice addr) inline {
    (int wc, int hp) = parse_std_addr(addr);
    return [wc, hp, addr];
}

([int, int, slice], int) std_workchain([int, int, slice] cntr) inline_ref {
    [int _wc?, int _hp?, slice _srlz?] = cntr; 
    return ([_wc?, _hp?, _srlz?], _wc?);
}

([int, int, slice], int) std_hashpart([int, int, slice] cntr) inline_ref {
    [int _wc?, int _hp?, slice _srlz?] = cntr; 
    return ([_wc?, _hp?, _srlz?], _hp?);
}

([int, int, slice], slice) std_serialize([int, int, slice] cntr) inline_ref {
    [int _wc?, int _hp?, slice _srlz?] = cntr; 

    if _srlz?.null?() {
        _srlz? = begin_cell().store_uint(4, 3) ;; 0b100 = addr_std$10 tag; No anycast
            .store_int(_wc?, 8)
            .store_uint(_hp?, 256)
        .end_cell().begin_parse();
    }

    return ([_wc?, _hp?, _srlz?], _srlz?);
}
